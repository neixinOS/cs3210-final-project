E2:
$ make gdb
gdb -q
+ target remote localhost:26000
warning: A handler for the OS ABI "GNU/Linux" is not built into this configuration
of GDB.  Attempting to continue with the default i8086 settings.

The target architecture is assumed to be i8086
[f000:fff0]    0xffff0:	ljmp   $0xf000,$0xe05b
0x0000fff0 in ?? ()
+ symbol-file obj/kern/kernel
(gdb) b env_pop_tf
Breakpoint 1 at 0xf010398c: file kern/env.c, line 482.
(gdb) c
Continuing.
The target architecture is assumed to be i386
=> 0xf010398c <env_pop_tf>:	push   %ebp

Breakpoint 1, env_pop_tf (tf=0xf01a1000) at kern/env.c:482
482	{
(gdb) si
=> 0xf010398d <env_pop_tf+1>:	mov    %esp,%ebp
0xf010398d	482	{
(gdb) si
=> 0xf010398f <env_pop_tf+3>:	sub    $0x18,%esp
0xf010398f	482	{
(gdb) si
=> 0xf0103992 <env_pop_tf+6>:	mov    0x8(%ebp),%esp
483	  __asm __volatile("movl %0,%%esp\n"
(gdb) si
=> 0xf0103995 <env_pop_tf+9>:	popa   
0xf0103995	483	  __asm __volatile("movl %0,%%esp\n"
(gdb) si
=> 0xf0103996 <env_pop_tf+10>:	pop    %es
0xf0103996 in env_pop_tf (
    tf=<error reading variable: Unknown argument list address for `tf'.>) at kern/env.c:483
483	  __asm __volatile("movl %0,%%esp\n"
(gdb) si
=> 0xf0103997 <env_pop_tf+11>:	pop    %ds
0xf0103997	483	  __asm __volatile("movl %0,%%esp\n"
(gdb) si
=> 0xf0103998 <env_pop_tf+12>:	add    $0x8,%esp
0xf0103998	483	  __asm __volatile("movl %0,%%esp\n"
(gdb) si
=> 0xf010399b <env_pop_tf+15>:	iret   
0xf010399b	483	  __asm __volatile("movl %0,%%esp\n"
(gdb) si
=> 0x800020:	cmp    $0xeebfe000,%esp
0x00800020 in ?? ()
(gdb) si
=> 0x800026:	jne    0x80002c
0x00800026 in ?? ()
(gdb) b *0x800add
Breakpoint 2 at 0x800add
(gdb) c
Continuing.
=> 0x800add:	int    $0x30

Breakpoint 2, 0x00800add in ?? ()
(gdb)

E4.
inc/trap.h,  x86 trap and interrupt constants.
// Trap numbers
// These are processor defined:
#define T_DIVIDE     0          // divide error
#define T_DEBUG      1          // debug exception
#define T_NMI        2          // non-maskable interrupt
#define T_BRKPT      3          // breakpoint
#define T_OFLOW      4          // overflow
#define T_BOUND      5          // bounds check
#define T_ILLOP      6          // illegal opcode
#define T_DEVICE     7          // device not available
#define T_DBLFLT     8          // double fault
/* #define T_COPROC  9 */       // reserved (not generated by recent processors)
#define T_TSS       10          // invalid task switch segment
#define T_SEGNP     11          // segment not present
#define T_STACK     12          // stack exception
#define T_GPFLT     13          // general protection fault
#define T_PGFLT     14          // page fault
/* #define T_RES    15 */       // reserved
#define T_FPERR     16          // floating point error
#define T_ALIGN     17          // aligment check
#define T_MCHK      18          // machine check
#define T_SIMDERR   19          // SIMD floating point error

Challenge:
First we need to define a table to store traps in trapentry.S, so that in trap.c, we could simply traverse the table to create the handler, i.e. SETGATE(idt[i], 0, GD_KT, table[i], 0). In trapentry.S, we have to create macros trap_handler and trap_handler_noec which correspond to TRAPHANDLER and TRAPHANDLER_NOEC respectively. The .data saves function entry, and the .text defines the function. Two macros are almost the same, unless the trap_handler_noec pushes a 0 in place of the error code like what the TRAPHANDLER_NOEC does.

Q1.
Because we have to handle exception/interrupt in different ways. Each exception/interrupt needs to have its own processing function; otherwise, it can not distinguish what is happening, what kind of exception/interrupt occurs.

Q2.
We should set the DPL to 3 to allow users invoke int $14. When the CPL is 3 (user level), but the INT n instruction is privilege level 0 (kernel level), it will result in a protection fault. But if the user are allowed to directly call the INT 14 (page fault), they can access without a kernel permission to allocate memory.

Part B:
Q3.
The cause of the exception to a general protection IDT is set the privilege level of the break point is set to 0 (kernel level), so by the user to access will certainly be a protection error. If it is set to 3, the protection of the error will disappear. We need to set the dpl to enable user to invoke it.

Q4.
The point is protection, since these mechanisms will not allow the user to directly attributable to protect the kernel.

E7.
In inc/trap.h
#define T_SYSCALL   48          // system call

$ make run-hello-nox
…
[00000000] new env 00001000
Incoming TRAP frame at 0xefffffbc
hello, world
Incoming TRAP frame at 0xefffffbc
[00001000] user fault va 00000048 ip 0080004a
TRAP frame at 0xf01a1000
  edi  0x00000000
  esi  0x00000000
  ebp  0xeebfdfd0
  oesp 0xefffffdc
  ebx  0x00000000
  edx  0xeebfde88
  ecx  0x0000000d
  eax  0x00000000
  es   0x----0023
  ds   0x----0023
  trap 0x0000000e Page Fault
  cr2  0x00000048
  err  0x00000004 [user, read, not-present]
  eip  0x0080004a
  cs   0x----001b
  flag 0x00000092
  esp  0xeebfdfb8
  ss   0x----0023
[00001000] free env 00001000
Destroyed the only environment - nothing more to do!

E9.
$ make run-buggyhello-nox
…
[00000000] new env 00001000
Incoming TRAP frame at 0xefffffbc
Incoming TRAP frame at 0xefffffbc
[00001000] user_mem_check assertion failure for va 00000001
[00001000] free env 00001000
Destroyed the only environment - nothing more to do!

E10.
$ make run-evilhello-nox
…
[00000000] new env 00001000
Incoming TRAP frame at 0xefffffbc
Incoming TRAP frame at 0xefffffbc
[00001000] user_mem_check assertion failure for va f010000c
[00001000] free env 00001000
Destroyed the only environment - nothing more to do!

