/* See COPYRIGHT for copyright information. */

#include <inc/mmu.h>
#include <inc/memlayout.h>
#include <inc/trap.h>



###################################################################
# exceptions/interrupts
###################################################################

/* TRAPHANDLER defines a globally-visible function for handling a trap.
 * It pushes a trap number onto the stack, then jumps to _alltraps.
 * Use TRAPHANDLER for traps where the CPU automatically pushes an error code.
 *
 * You shouldn't call a TRAPHANDLER function from C, but you may
 * need to _declare_ one in C (for instance, to get a function pointer
 * during IDT setup).  You can declare the function with
 *   void NAME();
 * where NAME is the argument passed to TRAPHANDLER.
 */
#define TRAPHANDLER(name, num)                                          \
        .globl name;            /* define global symbol for 'name' */   \
        .type name, @function;  /* symbol type is function */           \
        .align 2;               /* align function definition */         \
        name:                   /* function starts here */              \
        pushl $(num);                                                   \
        jmp _alltraps

/* Use TRAPHANDLER_NOEC for traps where the CPU doesn't push an error code.
 * It pushes a 0 in place of the error code, so the trap frame has the same
 * format in either case.
 */
#define TRAPHANDLER_NOEC(name, num)                                     \
        .globl name;                                                    \
        .type name, @function;                                          \
        .align 2;                                                       \
        name:                                                           \
        pushl $0;                                                       \
        pushl $(num);                                                   \
        jmp _alltraps

.text

/*
 * Lab 3: Your code here for generating entry points for the different traps.
 */
	TRAPHANDLER_NOEC(divide_error, T_DIVIDE)									# Divide error
	TRAPHANDLER_NOEC(debug, T_DEBUG)													# Debug
	TRAPHANDLER_NOEC(nmi, T_NMI)															# Non-Maskable Interrupt
  TRAPHANDLER_NOEC(breakpoint, T_BRKPT)											# Breakpoint
	TRAPHANDLER_NOEC(overflow, T_OFLOW)												# Overflow
	TRAPHANDLER_NOEC(bound, T_BOUND)													# BOUND Range Exceeded
	TRAPHANDLER_NOEC(illegal_op, T_ILLOP)											# Invalid Opcode
	TRAPHANDLER_NOEC(device_not_available, T_DEVICE)					# Device Not Available
	TRAPHANDLER(double_fault, T_DBLFLT)												# Double Fault
	//TRAPHANDLER_NOEC(coprocessor_segment_overrun, T_COPROC)		# Coprocessor Segment Overrun
	TRAPHANDLER(invalid_TSS, T_TSS)														# Invalid TSS
	TRAPHANDLER(segment_not_present, T_SEGNP)									# Segment Not Present
	TRAPHANDLER(stack_segment, T_STACK)												# Stack Fault
	TRAPHANDLER(general_protection, T_GPFLT)									# General Protection
	TRAPHANDLER(page_fault, T_PGFLT)													# Page Fault
	//TRAPHANDLER_NOEC(reserved, T_RES)													# (unknown trap)
	TRAPHANDLER_NOEC(float_point_error, T_FPERR)							# x87 FPU Floating-Point Error
	TRAPHANDLER(alignment_check, T_ALIGN)											# Alignment Check
	TRAPHANDLER_NOEC(machine_check, T_MCHK)										# Machine-Check
	TRAPHANDLER_NOEC(SIMD_float_point_error, T_SIMDERR)				# SIMD Floating-Point Exception

/*
 * Lab 3: Your code here for _alltraps
 */
_alltraps:
  # push values to make the stack look like a struct Trapframe
  pushl %ds
  pushl %es
  pushal
  # load GD_KD into %ds and %es
  movl $GD_KD, %eax
  movw %ax,%ds
  movw %ax,%es
  # pushl %esp to pass a pointer to the Trapframe as an argument to trap()
  pushl %esp
  # call trap (can trap ever return?)
  movl $0, %ebp
  call trap
  # iret return?


