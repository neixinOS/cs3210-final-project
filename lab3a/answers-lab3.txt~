E2:
$ make gdb
gdb -q
+ target remote localhost:26000
warning: A handler for the OS ABI "GNU/Linux" is not built into this configuration
of GDB.  Attempting to continue with the default i8086 settings.

The target architecture is assumed to be i8086
[f000:fff0]    0xffff0:	ljmp   $0xf000,$0xe05b
0x0000fff0 in ?? ()
+ symbol-file obj/kern/kernel
(gdb) b env_pop_tf
Breakpoint 1 at 0xf010398c: file kern/env.c, line 482.
(gdb) c
Continuing.
The target architecture is assumed to be i386
=> 0xf010398c <env_pop_tf>:	push   %ebp

Breakpoint 1, env_pop_tf (tf=0xf01a1000) at kern/env.c:482
482	{
(gdb) si
=> 0xf010398d <env_pop_tf+1>:	mov    %esp,%ebp
0xf010398d	482	{
(gdb) si
=> 0xf010398f <env_pop_tf+3>:	sub    $0x18,%esp
0xf010398f	482	{
(gdb) si
=> 0xf0103992 <env_pop_tf+6>:	mov    0x8(%ebp),%esp
483	  __asm __volatile("movl %0,%%esp\n"
(gdb) si
=> 0xf0103995 <env_pop_tf+9>:	popa   
0xf0103995	483	  __asm __volatile("movl %0,%%esp\n"
(gdb) si
=> 0xf0103996 <env_pop_tf+10>:	pop    %es
0xf0103996 in env_pop_tf (
    tf=<error reading variable: Unknown argument list address for `tf'.>) at kern/env.c:483
483	  __asm __volatile("movl %0,%%esp\n"
(gdb) si
=> 0xf0103997 <env_pop_tf+11>:	pop    %ds
0xf0103997	483	  __asm __volatile("movl %0,%%esp\n"
(gdb) si
=> 0xf0103998 <env_pop_tf+12>:	add    $0x8,%esp
0xf0103998	483	  __asm __volatile("movl %0,%%esp\n"
(gdb) si
=> 0xf010399b <env_pop_tf+15>:	iret   
0xf010399b	483	  __asm __volatile("movl %0,%%esp\n"
(gdb) si
=> 0x800020:	cmp    $0xeebfe000,%esp
0x00800020 in ?? ()
(gdb) si
=> 0x800026:	jne    0x80002c
0x00800026 in ?? ()
(gdb) b *0x800add
Breakpoint 2 at 0x800add
(gdb) c
Continuing.
=> 0x800add:	int    $0x30

Breakpoint 2, 0x00800add in ?? ()
(gdb)

E4.
inc/trap.h,  x86 trap and interrupt constants.
// Trap numbers
// These are processor defined:
#define T_DIVIDE     0          // divide error
#define T_DEBUG      1          // debug exception
#define T_NMI        2          // non-maskable interrupt
#define T_BRKPT      3          // breakpoint
#define T_OFLOW      4          // overflow
#define T_BOUND      5          // bounds check
#define T_ILLOP      6          // illegal opcode
#define T_DEVICE     7          // device not available
#define T_DBLFLT     8          // double fault
/* #define T_COPROC  9 */       // reserved (not generated by recent processors)
#define T_TSS       10          // invalid task switch segment
#define T_SEGNP     11          // segment not present
#define T_STACK     12          // stack exception
#define T_GPFLT     13          // general protection fault
#define T_PGFLT     14          // page fault
/* #define T_RES    15 */       // reserved
#define T_FPERR     16          // floating point error
#define T_ALIGN     17          // aligment check
#define T_MCHK      18          // machine check
#define T_SIMDERR   19          // SIMD floating point error

Challenge:
First we need to define a table to store traps in trapentry.S, so that in trap.c, we could simply traverse the table to create the handler, i.e. SETGATE(idt[i], 0, GD_KT, table[i], 0). In trapentry.S, we have to create macros trap_handler and trap_handler_noec which correspond to TRAPHANDLER and TRAPHANDLER_NOEC respectively. The .data saves function entry, and the .text defines the function. Two macros are almost the same, unless the trap_handler_noec pushes a 0 in place of the error code like what the TRAPHANDLER_NOEC does.

Q1.
Because we have to handle exception/interrupt in different ways. Each exception/interrupt needs to have its own processing function; otherwise, it can not distinguish what is happening, what kind of exception/interrupt occurs.

Q2.
We should set the DPL to 3 to allow users invoke int $14. When the CPL is 3 (user level), but the INT n instruction is privilege level 0 (kernel level), it will result in a protection fault. But if the user are allowed to directly call the INT 14 (page fault), they can access without a kernel permission to allocate memory.

